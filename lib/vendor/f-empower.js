// Generated by CoffeeScript 1.10.0
"use strict";
var slice1 = [].slice;

define(function() {

  /*
  F-EMPOWER
  A set of functions to harness the power functional programming in JS.
  Author: Ivan Fedorov <sharp.maestro@gmail.com>
  License: MIT
   */
  var Errors, Reduced, ReducedClass, THRESHOLD_LARGE_ARRAY_SIZE, _async_mapper, _clonedeep, _clonedeep2, _compare_crit, _compare_string, _suit_sort, a_contains, a_each, a_filter, a_find_index, a_index_of, a_map, a_reduce, a_reject, a_sum, add2, and2, and_r, any, apply, assign, assign_keys, assign_one, base_find_index_r, bind, bind_all, butlast, calc_shortest_length, cat, check_keys, check_true, clone, clone_obj, cloneassign, clonedeep, comma, compact, complement, compose, contains, count, count1, count_obj, count_pred, create, debounce, debug_wrap, dec, defaults, defaults2, delay, difference, difference_objs_vals, difference_sets, dispatch_find_index_matcher, drop, drop_last, each, each2, each3, each_idx, each_idx2, each_idxn, eachn, equal, equal2, equal_array, equal_array_start, equal_bool, equal_number, equal_object, equal_set, equal_val, every, every_fn, exports, extend, filter, filter_fn, filter_obj, filter_obj_1kv, filter_obj_2kv, filter_prop, filter_re, find, find_index, find_index_fn, find_index_last, find_index_obj, find_index_obj_1kv, find_index_obj_2kv, find_index_prop, first, flatten, flatten_path, flattenp, flattenp_recursive, flow, for_own, format, head, inc, index_by, index_of, insert_at, interpose, intersection, invoke, invoke0, invoke1, invokem, invokem0, invokem1, invokemn, invoken, is_arguments, is_array, is_array_like, is_atomic, is_boolean, is_date, is_defined, is_empty, is_empty$, is_even, is_function, is_mergeable, is_number, is_object, is_plain_object, is_regexp, is_string, is_subset, is_zero, jquery_wrap_to_array, keys, last, list, list_compact, log_pipe, make_array, map, map2, map3, map_async, mapn, match, matches, merge, merge_with, mk_regexp, multicall, native_concat, native_index_of, native_locale_compare, native_slice, next, no_operation, not_array, not_boolean, not_contains, not_date, not_defined, not_empty, not_empty$, not_function, not_mergeable, not_number, not_object, not_string, not_subset, not_zero, o_for_own, o_map, o_match, o_set, omit, omit_all, partial, partialr, pbind, periodically, pick, pick_all, pluck, prelast, prev, pull, push, push_all, range, read, read_1kv, recurse, reduce, reducer, reject, reject_fn, reject_obj, reject_obj_1kv, reject_obj_2kv, reject_prop, remap, remap2, remap3, remove, remove_at, repeat, repeatf, rest, reverse, second, set, set_interval, set_symmetric_difference, slice, sort, sort_fn, sort_multi, sort_prop, space, splice, str, str_breplace, str_join, str_split, sum2, tail, take, third, throttle, time, to_string, transform, transform2, transform3, trim, type_of, type_of2, union, unique, unique_by_prop, unique_plain, unshift, update_in, vals, varynum, without, wrap_invoke_obj, write, zip_obj;
  THRESHOLD_LARGE_ARRAY_SIZE = 64000;
  Errors = {
    NO_KEY_VALUE_PAIR_IN_HASH: new Error('No key value pair in a criterion hash'),
    NOT_FUNCTION: new TypeError('Something is not function'),
    UNEXPECTED_TYPE: new TypeError('Unexpected type')
  };
  ReducedClass = function(val) {
    this.val = val;
  };
  Reduced = function(val) {
    return new ReducedClass(val);
  };
  to_string = Object.prototype.toString;
  native_concat = Array.prototype.concat;
  native_index_of = Array.prototype.indexOf;
  native_slice = Array.prototype.slice;
  slice = function(array_or_arguments, start_idx, end_idx) {
    return native_slice.call(array_or_arguments, start_idx, end_idx);
  };
  bind = function(fn, this_arg) {
    return function() {
      return fn.apply(this_arg, arguments);
    };
  };
  partial = function() {
    var args, fn;
    fn = arguments[0];
    args = slice(arguments, 1);
    return function() {
      return fn.apply(null, args.concat(slice(arguments)));
    };
  };
  apply = function(fn, args_list) {
    return fn.apply(this, args_list);
  };
  add2 = function(a, b) {
    return a + b;
  };
  and2 = function(a, b) {
    return a && b;
  };
  and_r = function(a, b) {
    return (a && b) || Reduced(false);
  };
  bind_all = function() {
    var props, this_arg;
    props = butlast(arguments);
    this_arg = last(arguments);
    return a_each(props, function(prop) {
      return this_arg[prop] = bind(this_arg[prop], this_arg);
    });
  };
  compose = function() {
    var functions, item, k, len3;
    functions = arguments;
    for (k = 0, len3 = functions.length; k < len3; k++) {
      item = functions[k];
      if (not_function(item)) {
        throw Errors.NOT_FUNCTION;
      }
    }
    return function() {
      var i, memo;
      memo = arguments;
      i = functions.length;
      while (--i >= 0) {
        memo = [functions[i].apply(null, memo)];
      }
      return first(memo);
    };
  };
  complement = function(predicate) {
    return function() {
      return !(apply(predicate, arguments));
    };
  };
  debounce = function(debounce_timeout, fn) {
    var exec, last_args, last_result, last_this, last_timeout_id;
    if (arguments.length === 1) {
      fn = debounce_timeout;
      debounce_timeout = 0;
    }
    last_result = void 0;
    last_args = null;
    last_timeout_id = null;
    last_this = null;
    exec = function() {
      return last_result = fn.apply(last_this, last_args);
    };
    return function() {
      last_args = slice(arguments);
      last_this = this;
      clearTimeout(last_timeout_id);
      last_timeout_id = delay(debounce_timeout, exec);
      return last_result;
    };
  };
  debug_wrap = function(fn) {
    return function() {
      debugger;
      return fn.apply(null, arguments);
    };
  };
  delay = function(delay_ms, fn) {
    if (arguments.length === 1) {
      fn = delay_ms;
      delay_ms = 0;
    }
    return setTimeout(fn, delay_ms);
  };
  flow = function() {
    var functions, item, k, len3;
    functions = arguments;
    for (k = 0, len3 = functions.length; k < len3; k++) {
      item = functions[k];
      if (not_function(item)) {
        throw Errors.NOT_FUNCTION;
      }
    }
    return function() {
      var i, len, memo;
      memo = arguments;
      len = functions.length;
      i = -1;
      while (++i < len) {
        memo = [functions[i].apply(null, memo)];
      }
      return first(memo);
    };
  };
  multicall = function(fns) {
    fns = compact(fns);
    return function() {
      var fn, k, len3;
      for (k = 0, len3 = fns.length; k < len3; k++) {
        fn = fns[k];
        fn.apply(this, arguments);
      }
    };
  };
  no_operation = function() {};
  partialr = function(fn, right_args) {
    right_args = slice(arguments, 1);
    return function() {
      return apply(fn, cat(apply(list, arguments), right_args));
    };
  };
  periodically = function(interval, countdown, fn) {
    var interval_id;
    if ((not_number(countdown)) || (countdown < 1)) {
      throw new Error("Bad countdown");
    }
    return interval_id = set_interval(interval, function() {
      fn();
      countdown = countdown - 1;
      if (0 === countdown) {
        return clearInterval(interval_id);
      }
    });
  };
  pbind = function(fn) {
    return function() {
      return fn.apply(null, cat([this], slice(arguments)));
    };
  };
  set_interval = function(ms, fn) {
    if (!fn) {
      fn = ms;
      ms = 0;
    }
    return setInterval(fn, ms);
  };
  throttle = function(throttle_millis, fn) {
    var last_args, last_result, locked, should_call;
    locked = false;
    should_call = false;
    last_args = null;
    last_result = null;
    return function() {
      var void_main;
      last_args = slice(arguments);
      if (locked) {
        should_call = true;
        return last_result;
      } else {
        locked = true;
        last_result = fn.apply(null, last_args);
        void_main = function() {
          return delay(throttle_millis, function() {
            if (should_call) {
              last_result = fn.apply(null, last_args);
              should_call = false;
              return void_main();
            } else {
              return locked = false;
            }
          });
        };
        void_main();
        return last_result;
      }
    };
  };
  is_atomic = function(val) {
    switch (type_of2(val)) {
      case '[object Object]':
      case '[object Array]':
      case '[object Date]':
        return false;
      default:
        return true;
    }
  };
  is_arguments = function(v) {
    return '[object Arguments]' === (type_of2(v));
  };
  is_array = Array.isArray;
  is_array_like = function(v) {
    return is_number(v.length);
  };
  is_boolean = function(v) {
    return 'boolean' === (typeof v);
  };
  is_date = function(val) {
    return '[object Date]' === (type_of2(val));
  };
  is_defined = function(subj) {
    return 'undefined' !== (typeof subj);
  };
  is_empty = function(o) {
    return 0 === (count1(o));
  };
  is_empty$ = function(o) {
    return !o || (is_empty(o));
  };
  is_even = function(num) {
    return 0 === (num % 2);
  };
  is_function = function(candidate) {
    return 'function' === typeof candidate;
  };
  is_number = function(candidate) {
    return 'number' === typeof candidate;
  };
  is_object = function(candidate) {
    return 'object' === typeof candidate;
  };
  is_plain_object = function(subj) {
    var ctor, is_defnd, is_objct, key, latest_key, val;
    is_defnd = 'undefined' !== typeof subj;
    is_objct = is_defnd && ('[object Object]' === to_string.call(subj)) && !(is_function(subj));
    if (!is_objct || (!hasOwnProperty.call(subj, 'constructor') && ((ctor = subj.constructor) && (is_function(ctor)) && !(ctor instanceof ctor)))) {
      return false;
    }
    latest_key = null;
    for (key in subj) {
      val = subj[key];
      latest_key = key;
    }
    return (not_defined(key)) || hasOwnProperty.call(subj, latest_key);
  };
  is_mergeable = function(item) {
    return (is_array(item)) || (is_plain_object(item));
  };
  is_regexp = function(item) {
    return '[object RegExp]' === (type_of2(item));
  };
  is_string = function(item) {
    return "string" === (type_of(item));
  };
  is_subset = function(subset, superset) {
    return is_empty(difference(subset, superset));
  };
  is_zero = function(candidate) {
    return candidate === 0;
  };
  not_array = complement(is_array);
  not_boolean = complement(is_boolean);
  not_date = complement(is_date);
  not_defined = complement(is_defined);
  not_empty = complement(is_empty);
  not_empty$ = complement(is_empty$);
  not_function = complement(is_function);
  not_mergeable = complement(is_mergeable);
  not_number = complement(is_number);
  not_object = complement(is_object);
  not_string = complement(is_string);
  not_subset = complement(is_subset);
  not_zero = complement(is_zero);
  butlast = function(array) {
    return slice(array, 0, (count1(array)) - 1);
  };
  cat = function(array) {
    return native_concat.apply(array, slice(arguments, 1));
  };
  contains = function(searched_item, array) {
    var item, k, len3;
    for (k = 0, len3 = array.length; k < len3; k++) {
      item = array[k];
      if (searched_item === item) {
        return true;
      }
    }
    return false;
  };
  not_contains = complement(contains);
  a_contains = function(array, searched_item) {
    var item, k, len3;
    for (k = 0, len3 = array.length; k < len3; k++) {
      item = array[k];
      if (searched_item === item) {
        return true;
      }
    }
    return false;
  };
  a_each = function(array, fn) {
    return each(fn, array);
  };
  a_filter = function(array, fn) {
    return filter(fn, array);
  };
  a_find_index = function(array, pred) {
    return find_index(pred, array);
  };
  a_index_of = function(array, item) {
    return array.indexOf(item);
  };
  a_map = function(array, fn) {
    return map(fn, array);
  };
  a_reduce = function(array, val, fn) {
    if (is_function(val)) {
      return reduce(val, array);
    } else {
      return reduce(fn, val, array);
    }
  };
  a_reject = function(array, fn) {
    return reject(fn, array);
  };
  any = function(pred, arr) {
    if (arguments.length === 1) {
      arr = pred;
      pred = true;
    }
    return -1 !== (find_index(pred, arr));
  };
  compact = function(coll) {
    var item, k, len3, results1;
    results1 = [];
    for (k = 0, len3 = coll.length; k < len3; k++) {
      item = coll[k];
      if (item) {
        results1.push(item);
      }
    }
    return results1;
  };
  count = function(pred, coll) {
    if (!coll) {
      return count1(pred);
    } else if (!pred) {
      return coll.length;
    } else {
      if (is_function(pred)) {
        return count_pred(pred, coll);
      } else {
        return count_obj(pred, coll);
      }
    }
  };
  count1 = function(o) {
    if (is_array_like(o)) {
      return o.length;
    } else {
      return (keys(o)).length;
    }
  };
  count_obj = function(pred, coll) {
    return (filter(pred, coll)).length;
  };
  count_pred = function(pred, coll) {
    var cnt, item, k, len3;
    cnt = 0;
    for (k = 0, len3 = coll.length; k < len3; k++) {
      item = coll[k];
      if (pred(item)) {
        cnt++;
      }
    }
    return cnt;
  };
  drop = function(items_number_to_drop, array_like) {
    return slice(array_like, items_number_to_drop);
  };
  drop_last = function(chars_to_drop, string) {
    var len;
    len = string.length;
    if (chars_to_drop > len) {
      return "";
    } else {
      return string.substring(0, len - chars_to_drop);
    }
  };
  each = function(fn, coll) {
    switch (arguments.length) {
      case 0:
      case 1:
        throw new Error("Each doesn't have a signature of that arity");
        break;
      case 2:
        return each2(fn, coll);
      case 3:
        return each3(fn, coll, arguments[2]);
      default:
        return apply(eachn, arguments);
    }
  };
  each2 = function(fn, arr) {
    var item, k, len3;
    for (k = 0, len3 = arr.length; k < len3; k++) {
      item = arr[k];
      fn(item);
    }
  };
  each3 = function(fn, arr1, arr2) {
    var i, length_of_shortest;
    length_of_shortest = Math.min(count1(arr1), count1(arr2));
    i = -1;
    while (++i < length_of_shortest) {
      fn(arr1[i], arr2[i]);
    }
  };
  calc_shortest_length = function(arrs) {
    return apply(Math.min, map2(count1, arrs));
  };
  eachn = function() {
    var args, arrs, fn, i, local_apply, local_pluck, shortest_len;
    args = arguments;
    fn = first(args);
    arrs = rest(args);
    shortest_len = calc_shortest_length(arrs);
    i = -1;
    local_pluck = pluck;
    local_apply = apply;
    while (++i < shortest_len) {
      local_apply(fn, local_pluck(i, arrs));
    }
  };
  each_idx = function() {
    if (arguments.length === 2) {
      return each_idx2(arguments[0], arguments[1]);
    } else {
      return apply(each_idxn, arguments);
    }
  };
  each_idx2 = function(fn, arr) {
    var i, len;
    len = arr.length;
    i = -1;
    while (++i < len) {
      fn(arr[i], i);
    }
  };
  each_idxn = function() {
    var args, arrs, fn, local_apply, local_pluck, shortest_len;
    fn = first(arguments);
    arrs = rest(arguments);
    shortest_len = calc_shortest_length(arrs);
    local_pluck = pluck;
    local_apply = apply;
    while (++i < shortest_len) {
      args = local_pluck(i, arrs);
      args.push(i);
      local_apply(fn, args);
    }
  };
  check_keys = function(obj, keys_to_check) {
    return every(wrap_invoke_obj(obj), keys_to_check);
  };
  check_true = function(val) {
    return val === true;
  };
  every = function(pred, coll) {
    if (!coll) {
      coll = pred;
      pred = check_true;
    }
    if (is_empty(coll)) {
      return true;
    }
    return every_fn(pred, coll);
  };
  every_fn = function(fn, coll) {
    return a_reduce(coll, true, function(v1, v2) {
      return (v1 && (fn(v2))) || Reduced(false);
    });
  };
  first = function(array) {
    return array[0];
  };
  filter_fn = function(fn, arr) {
    var i, item, len, res;
    res = [];
    len = arr.length;
    i = -1;
    while (++i < len) {
      item = arr[i];
      if (fn(item)) {
        res.push(item);
      }
    }
    return res;
  };
  filter_prop = function(prop_name, arr) {
    var i, item, len, res;
    res = [];
    len = arr.length;
    i = -1;
    while (++i < len) {
      item = arr[i];
      if (item[prop_name]) {
        res.push(item);
      }
    }
    return res;
  };
  filter_obj_1kv = function(obj, array) {
    var item, k, key, len3, ref, results1, val;
    ref = read_1kv(obj), key = ref[0], val = ref[1];
    results1 = [];
    for (k = 0, len3 = array.length; k < len3; k++) {
      item = array[k];
      if (item[key] === val) {
        results1.push(item);
      }
    }
    return results1;
  };
  filter_obj_2kv = function(obj, array) {
    var item, k, key1, key2, len3, ref, ref1, results1, val1, val2;
    ref = keys(obj), key1 = ref[0], key2 = ref[1];
    ref1 = [obj[key1], obj[key2]], val1 = ref1[0], val2 = ref1[1];
    results1 = [];
    for (k = 0, len3 = array.length; k < len3; k++) {
      item = array[k];
      if (item[key1] === val1 && item[key2] === val2) {
        results1.push(item);
      }
    }
    return results1;
  };
  filter_obj = function(obj, array) {
    var item, k, len3, results1;
    results1 = [];
    for (k = 0, len3 = array.length; k < len3; k++) {
      item = array[k];
      if (o_match(obj, item)) {
        results1.push(item);
      }
    }
    return results1;
  };
  filter_re = function(regex, strings) {
    var k, len3, results, string;
    results = [];
    for (k = 0, len3 = strings.length; k < len3; k++) {
      string = strings[k];
      if (regex.test(string)) {
        results.push(string);
      }
    }
    return results;
  };
  filter = function(some_criteria, array) {
    switch (typeof some_criteria) {
      case "string":
        return filter_prop(some_criteria, array);
      case "function":
        return filter_fn(some_criteria, array);
      case "object":
        if (is_regexp(some_criteria)) {
          return filter_re(some_criteria, array);
        } else {
          switch (count1(keys(some_criteria))) {
            case 0:
              throw Errors.NO_KEY_VALUE_PAIR_IN_HASH;
              break;
            case 1:
              return filter_obj_1kv(some_criteria, array);
            case 2:
              return filter_obj_2kv(some_criteria, array);
            default:
              return filter_obj(some_criteria, array);
          }
        }
        break;
      default:
        throw Errors.UNEXPECTED_TYPE;
    }
  };
  find = function(some_criteria, array) {
    var item_idx;
    item_idx = find_index(some_criteria, array);
    if (item_idx === -1) {
      return;
    }
    return read(item_idx, array);
  };
  find_index = function(pred, array) {
    switch (typeof pred) {
      case "string":
        return find_index_prop(pred, array);
      case "function":
        return find_index_fn(pred, array);
      case "boolean":
      case "number":
        return index_of(pred, array);
      case "object":
        switch (count1(keys(pred))) {
          case 0:
            throw Errors.NO_KEY_VALUE_PAIR_IN_HASH;
            break;
          case 1:
            return find_index_obj_1kv(pred, array);
          case 2:
            return find_index_obj_2kv(pred, array);
          default:
            return find_index_obj(pred, array);
        }
        break;
      default:
        throw Errors.UNEXPECTED_TYPE;
    }
  };
  find_index_fn = function(fn, array) {
    var idx, item, k, len3;
    for (idx = k = 0, len3 = array.length; k < len3; idx = ++k) {
      item = array[idx];
      if (fn(item)) {
        return idx;
      }
    }
    return -1;
  };
  find_index_prop = function(prop_name, array) {
    var idx, item, k, len3;
    for (idx = k = 0, len3 = array.length; k < len3; idx = ++k) {
      item = array[idx];
      if (item[prop_name]) {
        return idx;
      }
    }
    return -1;
  };
  find_index_obj_1kv = function(obj_with_1kv_pair, array) {
    var idx, item, k, key, len3, ref, val;
    ref = read_1kv(obj_with_1kv_pair), key = ref[0], val = ref[1];
    for (idx = k = 0, len3 = array.length; k < len3; idx = ++k) {
      item = array[idx];
      if (item[key] === val) {
        return idx;
      }
    }
    return -1;
  };
  find_index_obj_2kv = function(obj_with_2kv_pair, array) {
    var idx, item, k, key1, key2, len3, ref, ref1, val1, val2;
    ref = keys(obj_with_2kv_pair), key1 = ref[0], key2 = ref[1];
    ref1 = [obj_with_2kv_pair[key1], obj_with_2kv_pair[key2]], val1 = ref1[0], val2 = ref1[1];
    for (idx = k = 0, len3 = array.length; k < len3; idx = ++k) {
      item = array[idx];
      if (item[key1] === val1 && item[key2] === val2) {
        return idx;
      }
    }
    return -1;
  };
  find_index_obj = function(obj, array) {
    var idx, item, k, len3;
    for (idx = k = 0, len3 = array.length; k < len3; idx = ++k) {
      item = array[idx];
      if (o_match(obj, item)) {
        return idx;
      }
    }
    return -1;
  };
  base_find_index_r = function(iter_fn, array) {
    var i;
    i = array.length;
    while (--i > -1) {
      if (iter_fn(array[i], i, array)) {
        return i;
      }
    }
    return -1;
  };
  equal_bool = function(b1, b2) {
    return b1 === b2;
  };
  equal_number = function(n1, n2) {
    return n1 === n2;
  };
  dispatch_find_index_matcher = function(pred) {
    switch (typeof pred) {
      case 'function':
        return pred;
      case 'boolean':
        return partial(equal_bool, pred);
      case 'number':
        return partial(equal_number, pred);
      default:
        throw new Error("No matcher for " + (typeof pred) + " yet");
    }
  };
  find_index_last = function(pred, array) {
    return base_find_index_r(dispatch_find_index_matcher(pred), array);
  };
  flatten = function(arr) {
    if (is_empty(arr)) {
      return [];
    } else {
      return apply(cat, arr);
    }
  };
  index_of = function(item, array) {
    return native_index_of.call(array, item);
  };
  insert_at = function(items, idx, item) {
    items.splice(idx, 0, item);
    return items;
  };
  last = function(list) {
    return list[dec(count1(list))];
  };
  list = function() {
    var args;
    return (count1((args = arguments))) && (slice(args)) || [];
  };
  list_compact = function() {
    var arg, k, len3, result;
    result = [];
    for (k = 0, len3 = arguments.length; k < len3; k++) {
      arg = arguments[k];
      if (!!arg) {
        result.push(arg);
      }
    }
    return result;
  };
  log_pipe = function(val) {
    console.log.apply(console, val);
    return val;
  };
  next = function(arr, item) {
    return arr[(index_of(item, arr)) + 1];
  };
  prev = function(arr, item) {
    return arr[(index_of(item, arr)) - 1];
  };
  type_of = function(mixed) {
    return typeof mixed;
  };
  type_of2 = function(val) {
    return to_string.call(val);
  };
  sort = function(criterion, arr) {
    switch (count1(arguments)) {
      case 1:
        return criterion.sort();
      case 2:
        if (2 > (count1(arr))) {
          return slice(arr);
        }
        switch (type_of(criterion)) {
          case "string":
            return sort_prop(criterion, arr);
          case "array":
            return sort_multi(criterion, arr);
          case "function":
            return sort_fn(criterion, arr);
        }
    }
  };
  sort_prop = function(prop, arr) {
    var compare_fn, need_string_comparison, sort_suitable_arr;
    sort_suitable_arr = map(partial(_suit_sort, prop), arr);
    need_string_comparison = is_string(arr[0][prop]);
    compare_fn = need_string_comparison && _compare_string || _compare_crit;
    return pluck('val', sort_suitable_arr.sort(compare_fn));
  };
  _suit_sort = function(prop, obj) {
    return {
      val: obj,
      criteria: obj[prop]
    };
  };
  _compare_crit = function(obj1, obj2) {
    return obj1.criteria - obj2.criteria;
  };
  native_locale_compare = String.prototype.localeCompare;
  _compare_string = function(obj1, obj2) {
    return native_locale_compare.call(obj1.criteria, obj2.criteria);
  };
  sort_multi = function(props_arr, arr) {};
  sort_fn = function(compare_fn, arr) {
    return arr.sort(compare_fn);
  };
  map = function(mapper, coll) {
    switch (arguments.length) {
      case 0:
      case 1:
        throw new Error("Map doesn't have a signature of that arity");
        break;
      case 2:
        switch (typeof mapper) {
          case 'function':
            return map2(mapper, coll);
          case 'string':
            return pluck(mapper, coll);
          case 'object':
            return o_map(mapper, coll);
        }
        break;
      case 3:
        return map3(mapper, coll, arguments[2]);
      default:
        return apply(mapn, arguments);
    }
  };
  _async_mapper = function(err_fn, map_fn, accumulator, report_arr, item, idx) {
    return map_fn(item, function(err, res) {
      if (err) {
        return err_fn(err);
      }
      accumulator[idx] = res;
      return report_arr[idx] = true;
    });
  };
  map_async = function(map_fn, items, on_res) {
    var err_fn, help_arr, int_id, len, res_arr;
    len = items.length;
    help_arr = repeat(len, false);
    res_arr = make_array(len);
    int_id = set_interval(2, function() {
      if (every(help_arr)) {
        clearInterval(int_id);
        return on_res(null, res_arr);
      }
    });
    err_fn = function(err) {
      clearInterval(int_id);
      return on_res(err);
    };
    return each_idx2(partial(_async_mapper, err_fn, map_fn, res_arr, help_arr), items);
  };
  make_array = function(len) {
    return (len > THRESHOLD_LARGE_ARRAY_SIZE) && [] || new Array(len);
  };
  map2 = function(fn, arr) {
    var i, len, result;
    i = -1;
    len = count1(arr);
    result = make_array(len);
    while (++i < len) {
      result[i] = fn(arr[i]);
    }
    return result;
  };
  map3 = function(fn, arr1, arr2) {
    var i, length_of_shortest, result;
    length_of_shortest = Math.min(count1(arr1), count1(arr2));
    i = -1;
    result = make_array(length_of_shortest);
    while (++i < length_of_shortest) {
      result[i] = fn(arr1[i], arr2[i]);
    }
    return result;
  };
  mapn = function() {
    var args, arrs, fn, i, local_apply, local_pluck, result, shortest_len;
    args = arguments;
    fn = first(args);
    arrs = rest(args);
    shortest_len = apply(Math.min, map2(count1, arrs));
    i = -1;
    local_pluck = pluck;
    local_apply = apply;
    result = make_array(shortest_len);
    while (++i < shortest_len) {
      result[i] = local_apply(fn, local_pluck(i, arrs));
    }
    return result;
  };
  not_contains = complement(contains);
  prelast = function(array) {
    return array[(count1(array)) - 2];
  };
  push = function(arr, item) {
    arr.push(item);
    return arr;
  };
  push_all = function(arr, items_to_push_arr) {
    arr.push.apply(arr, items_to_push_arr);
    return arr;
  };
  reduce = function(fn, val, array) {
    var idx, len;
    idx = -1;
    if (!array && (is_array_like(val))) {
      array = val;
      val = fn(first(array), second(array));
      idx = 1;
    }
    len = count1(array);
    while (++idx < len && (!val || val.constructor !== ReducedClass)) {
      val = fn(val, array[idx]);
    }
    if (val && val.constructor === ReducedClass) {
      return val.val;
    } else {
      return val;
    }
  };
  reducer = function(fn, val, arr) {
    var idx;
    idx = -1;
    if (!arr && (is_array(val))) {
      arr = val;
      val = fn(last(arr), prelast(arr));
      idx = (count1(arr)) - 2;
    } else {
      idx = count1(arr);
    }
    while (--idx > -1) {
      val = fn(val, arr[idx]);
    }
    return val;
  };
  reject_fn = function(fn, array) {
    var item, k, len3, results1;
    results1 = [];
    for (k = 0, len3 = array.length; k < len3; k++) {
      item = array[k];
      if (!(fn(item))) {
        results1.push(item);
      }
    }
    return results1;
  };
  reject_prop = function(prop_name, array) {
    var item, k, len3, results1;
    results1 = [];
    for (k = 0, len3 = array.length; k < len3; k++) {
      item = array[k];
      if (!item[prop_name]) {
        results1.push(item);
      }
    }
    return results1;
  };
  reject_obj_1kv = function(one_kv_pair_object, array) {
    var item, k, key, len3, ref, results1, val;
    ref = read_1kv(one_kv_pair_object), key = ref[0], val = ref[1];
    results1 = [];
    for (k = 0, len3 = array.length; k < len3; k++) {
      item = array[k];
      if (item[key] !== val) {
        results1.push(item);
      }
    }
    return results1;
  };
  reject_obj_2kv = function(two_kv_pairs_object, array) {
    var item, k, key1, key2, len3, ref, ref1, results1, val1, val2;
    ref = keys(two_kv_pairs_object), key1 = ref[0], key2 = ref[1];
    ref1 = [two_kv_pairs_object[key1], two_kv_pairs_object[key2]], val1 = ref1[0], val2 = ref1[1];
    results1 = [];
    for (k = 0, len3 = array.length; k < len3; k++) {
      item = array[k];
      if (!(item[key1] === val1 && item[key2] === val2)) {
        results1.push(item);
      }
    }
    return results1;
  };
  reject_obj = function(object, array) {
    var item, k, len3, results1;
    results1 = [];
    for (k = 0, len3 = array.length; k < len3; k++) {
      item = array[k];
      if (!(o_match(object, item))) {
        results1.push(item);
      }
    }
    return results1;
  };
  reject = function(some_criteria, array) {
    switch (typeof some_criteria) {
      case "string":
        return reject_prop(some_criteria, array);
      case "function":
        return reject_fn(some_criteria, array);
      case "object":
        switch (count1(keys(some_criteria))) {
          case 0:
            throw Errors.NO_KEY_VALUE_PAIR_IN_HASH;
            break;
          case 1:
            return reject_obj_1kv(some_criteria, array);
          case 2:
            return reject_obj_2kv(some_criteria, array);
          default:
            return reject_obj(some_criteria, array);
        }
        break;
      default:
        throw Errors.UNEXPECTED_TYPE;
    }
  };
  remap = function(fn, arr) {
    switch (arguments.length) {
      case 2:
        return remap2(fn, arr);
      case 3:
        return remap3(fn, arguments[1], arguments[2]);
    }
  };
  remap2 = function(fn, arr) {
    var item, item_idx, k, len3;
    for (item_idx = k = 0, len3 = arr.length; k < len3; item_idx = ++k) {
      item = arr[item_idx];
      arr[item_idx] = fn(item);
    }
    return arr;
  };
  remap3 = function(fn, prop, arr) {
    var item, item_idx, k, len3;
    for (item_idx = k = 0, len3 = arr.length; k < len3; item_idx = ++k) {
      item = arr[item_idx];
      arr[item_idx][prop] = fn(item[prop]);
    }
    return arr;
  };
  remove = function(item, arr) {
    var idx;
    idx = index_of(item, arr);
    return idx !== -1 && (remove_at(idx, arr));
  };
  remove_at = function(idx, arr) {
    return splice(arr, idx, 1);
  };
  repeat = function(times, value) {
    var array;
    array = make_array(times);
    while (--times > -1) {
      array[times] = value;
    }
    return array;
  };
  repeatf = function(times, fn) {
    var array;
    array = make_array(times);
    while (--times > -1) {
      array[times] = fn();
    }
    return array;
  };
  rest = function(arr) {
    return slice(arr, 1);
  };
  reverse = function(arr) {
    var i, j, len, res;
    len = arr.length;
    i = 0;
    j = len;
    res = new Array(len);
    while (--j > -1) {
      res[i] = arr[j];
      i += 1;
    }
    return res;
  };
  splice = bind(Function.prototype.call, Array.prototype.splice);
  second = function(array) {
    return array[1];
  };
  take = function(items_number_to_take, array_like) {
    return slice(array_like, 0, items_number_to_take);
  };
  third = function(arr) {
    return arr[2];
  };
  union = function(arr1, arr2) {
    var item, k, len3, result;
    result = arr1.slice();
    for (k = 0, len3 = arr2.length; k < len3; k++) {
      item = arr2[k];
      if (!(contains(item, arr1))) {
        result.push(item);
      }
    }
    return result;
  };
  unshift = function(arr, item) {
    arr.unshift(item);
    return arr;
  };
  without = function(item, arr) {
    remove(item, arr);
    return arr;
  };
  invoke = function(method_name, coll) {
    switch (arguments.length) {
      case 2:
        return invoke0(method_name, coll);
      case 3:
        return invoke1(method_name, coll, arguments[2]);
      default:
        return invoken.apply(null, arguments);
    }
  };
  invoke0 = function(method_name, coll) {
    var i, len, results;
    len = coll.length;
    results = make_array(len);
    i = -1;
    while (++i < len) {
      results[i] = coll[i][method_name]();
    }
    return results;
  };
  invoke1 = function(method_name, arg, coll) {
    var i, item, len, results;
    len = coll.length;
    results = make_array(len);
    i = -1;
    while (++i < len) {
      item = coll[i];
      results[i] = item[method_name].call(item, arg);
    }
    return results;
  };
  invoken = function() {
    var args, coll, i, item, k, len, method_name, results;
    method_name = arguments[0], args = 3 <= arguments.length ? slice1.call(arguments, 1, k = arguments.length - 1) : (k = 1, []), coll = arguments[k++];
    len = coll.length;
    results = make_array(len);
    i = -1;
    while (++i < len) {
      item = coll[i];
      results[i] = item[method_name].apply(item, args);
    }
    return results;
  };
  invokem = function(method_name, coll) {
    switch (arguments.length) {
      case 2:
        return invokem0(method_name, coll);
      case 3:
        return invokem1(method_name, coll, arguments[2]);
      default:
        return invokemn.apply(null, arguments);
    }
  };
  invokem1 = function(method_name, arg, coll) {
    var i, item, len;
    i = -1;
    len = coll.length;
    while (++i < len) {
      item = coll[i];
      item[method_name].call(item, arg);
    }
  };
  invokem0 = function(method_name, coll) {
    var i, len;
    i = -1;
    len = coll.length;
    while (++i < len) {
      coll[i][method_name]();
    }
  };
  invokemn = function() {
    var args, coll, i, item, k, len, method_name;
    method_name = arguments[0], args = 3 <= arguments.length ? slice1.call(arguments, 1, k = arguments.length - 1) : (k = 1, []), coll = arguments[k++];
    i = -1;
    len = coll.length;
    while (++i < len) {
      item = coll[i];
      item[method_name].apply(item, args);
    }
  };
  pluck = function(key, coll) {
    var i, len, result;
    len = count1(coll);
    result = make_array(len);
    i = -1;
    while (++i < len) {
      result[i] = coll[i][key];
    }
    return result;
  };
  varynum = function(numbers_arr, start_with_one) {
    var k, len3, number, results1, variator;
    variator = start_with_one && -1 || 1;
    results1 = [];
    for (k = 0, len3 = numbers_arr.length; k < len3; k++) {
      number = numbers_arr[k];
      variator *= -1;
      results1.push(number * variator);
    }
    return results1;
  };
  write = function(dst_coll, prop_name, src_coll) {
    var dst, idx, k, len3, src;
    for (idx = k = 0, len3 = dst_coll.length; k < len3; idx = ++k) {
      dst = dst_coll[idx];
      src = src_coll[idx];
      dst[prop_name] = src;
    }
    return dst_coll;
  };
  unique = function(prop, array) {
    if (array) {
      return unique_by_prop(prop, array);
    } else {
      array = prop;
      if (is_empty(array)) {
        return [];
      } else if ((is_number(array[0])) || (is_string(array[0]))) {
        return unique_plain(array);
      } else {
        throw Error("only propped uniq and plain number or string uniqueing supported");
      }
    }
  };
  unique_by_prop = function(prop_name, arr) {
    var help_hash, out;
    help_hash = {};
    out = [];
    a_each(arr, function(item) {
      var prop_val;
      prop_val = item[prop_name];
      if (!help_hash[prop_val]) {
        help_hash[prop_val] = true;
        return out.push(item);
      }
    });
    return out;
  };
  unique_plain = function(arr) {
    var help_hash, out;
    help_hash = {};
    out = [];
    a_each(arr, function(val) {
      if (!help_hash[val]) {
        help_hash[val] = true;
        return out.push(val);
      }
    });
    return out;
  };
  wrap_invoke_obj = function(o) {
    return function(key) {
      return o[key];
    };
  };
  assign = function(dest, sources) {
    if (dest == null) {
      dest = {};
    }
    return reduce(assign_one, dest, drop(1, arguments));
  };
  assign_keys = function(keys, dst, src) {
    var i, key, l;
    i = -1;
    l = keys.length;
    while (++i < l) {
      key = keys[i];
      if (void 0 !== src[key]) {
        dst[key] = src[key];
      }
    }
    return dst;
  };
  assign_one = function(dest, src) {
    var key, val;
    for (key in src) {
      val = src[key];
      dest[key] = val;
    }
    return dest;
  };
  clone = function(data) {
    if (is_object(data)) {
      if (is_array(data)) {
        return slice(data);
      } else {
        return clone_obj(data);
      }
    } else {
      throw Errors.UNEXPECTED_TYPE;
    }
  };
  cloneassign = function(dst, var_src) {
    return reduce(assign_one, clonedeep(dst), drop(1, arguments));
  };
  clonedeep = function(src) {
    var dst, stack_dst, stack_src;
    return _clonedeep(src, dst = (is_array(src)) && [] || {}, stack_dst = [dst], stack_src = [src]);
  };
  clone_obj = function(obj) {
    var key, res, val;
    res = {};
    for (key in obj) {
      val = obj[key];
      res[key] = val;
    }
    return res;
  };
  _clonedeep = function(src, dst, stack_dst, stack_src) {
    var child_dst, key, val, val_idx;
    for (key in src) {
      val = src[key];
      if (is_atomic(val)) {
        dst[key] = val;
      } else if (is_date(val)) {
        dst[key] = new Date(val.getTime());
      } else {
        val_idx = index_of(val, stack_src);
        if (val_idx === -1) {
          dst[key] = child_dst = (is_array(val)) && [] || {};
          stack_src.push(val);
          stack_dst.push(child_dst);
          _clonedeep(val, child_dst, stack_dst, stack_src);
        } else {
          dst[key] = stack_dst[val_idx];
        }
      }
    }
    return dst;
  };
  _clonedeep2 = function(src) {
    var child_dst, cur_dst, cur_key_idx, cur_keys, cur_src, dst, key, ref, stack_act, stack_dst, stack_src, val, val_idx;
    dst = (is_array(src)) && [] || {};
    cur_src = src;
    cur_dst = dst;
    stack_src = [src];
    stack_dst = [dst];
    stack_act = [];
    cur_keys = (is_array(cur_src)) && (range(count1(cur_src))) || (reverse(keys(cur_src)));
    cur_key_idx = count1(cur_keys);
    while (--cur_key_idx >= 0) {
      key = cur_keys[cur_key_idx];
      val = cur_src[key];
      if (is_atomic(val)) {
        cur_dst[key] = val;
      } else if (is_date(val)) {
        cur_dst[key] = new Date(val.getTime());
      } else {
        val_idx = index_of(val, stack_src);
        if (val_idx === -1) {
          child_dst = (is_array(val)) && [] || {};
          cur_dst[key] = child_dst;
          stack_act.push([cur_src, cur_dst, cur_keys, cur_key_idx]);
          cur_src = val;
          cur_dst = child_dst;
          cur_keys = (is_array(cur_src)) && (range(count1(cur_src))) || (reverse(keys(cur_src)));
          cur_key_idx = count1(cur_keys);
          stack_src.push(cur_src);
          stack_dst.push(cur_dst);
        } else {
          cur_dst[key] = stack_dst[val_idx];
        }
      }
      while ((is_zero(cur_key_idx)) && (not_zero(count1(stack_act)))) {
        ref = stack_act.pop(), cur_src = ref[0], cur_dst = ref[1], cur_keys = ref[2], cur_key_idx = ref[3];
      }
    }
    return dst;
  };
  create = function(ctor, arg) {
    return new ctor(arg);
  };
  defaults = function(dest) {
    if (dest == null) {
      dest = {};
    }
    return reduce(defaults2, dest, rest(arguments));
  };
  defaults2 = function(dest, source) {
    var key, val;
    for (key in source) {
      val = source[key];
      if ('undefined' === typeof dest[key]) {
        dest[key] = val;
      }
    }
    return dest;
  };
  difference = function(o1, o2) {
    if ((is_object(o1)) && (is_object(o2))) {
      if ((is_array(o1)) && (is_array(o2))) {
        return difference_sets(o1, o2);
      } else {
        return difference_objs_vals(o1, o2);
      }
    } else {
      throw new TypeError("Tried to find difference between not objects");
    }
  };
  difference_objs_vals = function(o1, o2) {
    var key, res, val1, val2;
    res = {};
    for (key in o1) {
      val1 = o1[key];
      if ((is_defined(val2 = o2[key])) && !(equal2(val1, val2))) {
        res[key] = val1;
      }
    }
    return res;
  };
  difference_sets = function(set_a, set_b, contains_fn) {
    if (contains_fn == null) {
      contains_fn = contains;
    }
    return a_reject(set_a, function(item) {
      return contains_fn(item, set_b);
    });
  };
  set_symmetric_difference = function(set_a, set_b, contains_fn) {
    return [difference_sets(set_a, set_b, contains_fn), difference_sets(set_b, set_a, contains_fn)];
  };
  equal = function() {
    var val;
    val = a_reduce(arguments, function(v1, v2) {
      return (equal2(v1, v2)) && v2 || (Reduced(false));
    });
    return !!val;
  };
  equal2 = function(o1, o2) {
    if ((o1 === null) || (o2 === null) || (o1 === void 0) || (o2 === void 0)) {
      return o1 === o2;
    } else if ((is_object(o1)) && (is_object(o2))) {
      if ((is_array(o1)) && (is_array(o2))) {
        return equal_array(o1, o2);
      } else if (is_date(o1)) {
        return o1.valueOf() === o2.valueOf();
      } else {
        return equal_object(o1, o2);
      }
    } else {
      return o1 === o2;
    }
  };
  equal_array = function(arr1, arr2) {
    var len1, len2;
    len1 = arr1.length;
    len2 = arr2.length;
    return ((0 === len1) && (0 === len2)) || ((len1 === len2) && (equal_array_start(arr1, arr2)));
  };
  equal_array_start = function(arr1, arr2) {
    return reduce(and_r, true, map(equal_val, arr1, arr2));
  };
  equal_object = function(o1, o2) {
    var keys1, keys2, vals1, vals2;
    keys1 = keys(o1);
    keys2 = keys(o2);
    if (keys1.length === keys2.length && (equal_set(keys1, keys2))) {
      vals1 = o_map(o1, keys1);
      vals2 = o_map(o2, keys1);
      return equal_array_start(vals1, vals2);
    } else {
      return false;
    }
  };
  equal_set = function(keyset1, keyset2) {
    var diff1, diff2, ref;
    ref = set_symmetric_difference(keyset1, keyset2), diff1 = ref[0], diff2 = ref[1];
    return (is_empty(diff1)) && (is_empty(diff2));
  };
  equal_val = function(v1, v2) {
    return v1 === v2;
  };
  extend = function(extended, extension) {
    return assign(Object.create(extended), extension);
  };
  flatten_path = function(prop, obj, opts) {
    var res;
    if (opts == null) {
      opts = {
        inlude_root: false
      };
    }
    res = opts.include_root && [obj] || [];
    while ((obj = obj[prop])) {
      res.push(obj);
    }
    return res;
  };
  flattenp = function(key, root, arg1) {
    var accumulator, include_root;
    include_root = (arg1 != null ? arg1 : {
      include_root: true
    }).include_root;
    accumulator = include_root && [root] || [];
    return flattenp_recursive(key, root, accumulator);
  };
  flattenp_recursive = function(key, root, accumulator) {
    var children, k, len3, son;
    push_all(accumulator, root[key]);
    if (children = root[key]) {
      for (k = 0, len3 = children.length; k < len3; k++) {
        son = children[k];
        flattenp_recursive(key, son, accumulator);
      }
    }
    return accumulator;
  };
  for_own = function(fn, obj) {
    a_each(keys(obj), function(key) {
      return fn(key, obj[key]);
    });
  };
  index_by = function(index_prop, list_to_index, accumulator) {
    var item, k, len3;
    if (accumulator == null) {
      accumulator = {};
    }
    for (k = 0, len3 = list_to_index.length; k < len3; k++) {
      item = list_to_index[k];
      accumulator[item[index_prop]] = item;
    }
    return accumulator;
  };
  interpose = function(sep, coll) {
    var coll_len, i_coll, i_res, new_len, new_res, seps_count;
    coll_len = coll.length;
    seps_count = coll_len - 1;
    new_len = coll_len + seps_count;
    new_res = make_array(new_len);
    i_coll = -1;
    i_res = 0;
    while (++i_coll < coll_len) {
      new_res[i_res] = coll[i_coll];
      if ((i_res + 1) < new_len) {
        new_res[i_res + 1] = sep;
      }
      i_res += 2;
    }
    return new_res;
  };
  intersection = function(coll1, coll2, contains_fn) {
    if (contains_fn == null) {
      contains_fn = contains;
    }
    return a_filter(coll1, function(item) {
      return contains_fn(item, coll2);
    });
  };
  keys = function(hash) {
    return Object.keys(hash);
  };
  merge = function(dst, src) {
    var call_stack, cur_dst, cur_key_idx, cur_keys, cur_src, key, ref, src_stack, val, val_idx;
    call_stack = [];
    src_stack = [];
    cur_dst = dst;
    cur_src = src;
    cur_keys = keys(src);
    cur_key_idx = count1(cur_keys);
    while (--cur_key_idx >= 0) {
      key = cur_keys[cur_key_idx];
      val = cur_src[key];
      if ((not_defined(cur_dst[key])) || (not_mergeable(val))) {
        cur_dst[key] = val;
        if (is_mergeable(val)) {
          src_stack.push(val);
        }
      } else {
        val_idx = index_of(val, src_stack);
        if (val_idx === -1) {
          call_stack.push([cur_dst, cur_src, cur_keys, cur_key_idx]);
          src_stack.push(val);
          cur_dst = cur_dst[key];
          cur_src = cur_src[key];
          cur_keys = keys(cur_src);
          cur_key_idx = count1(cur_keys);
        }
      }
      while ((is_zero(cur_key_idx)) && (not_empty(call_stack))) {
        ref = call_stack.pop(), cur_dst = ref[0], cur_src = ref[1], cur_keys = ref[2], cur_key_idx = ref[3];
      }
    }
    return dst;
  };
  merge_with = function(fn, o1, o2) {
    var k, key, keyset, len3, res, v1, v2;
    res = {};
    keyset = unique(cat(keys(o1), keys(o2)));
    for (k = 0, len3 = keyset.length; k < len3; k++) {
      key = keyset[k];
      v1 = o1[key];
      v2 = o2[key];
      if (v1 && v2) {
        res[key] = fn(v1, v2);
      } else {
        res[key] = v1 || v2;
      }
    }
    return res;
  };
  omit = function(obj, props) {
    return omit_all(obj, rest(arguments));
  };
  omit_all = function(obj, props_arr) {
    var key, res, val;
    res = {};
    for (key in obj) {
      val = obj[key];
      if (not_contains(key, props_arr)) {
        res[key] = val;
      }
    }
    return res;
  };
  o_for_own = function(obj, fn) {
    return for_own(fn, obj);
  };
  o_map = function(hash, keys_list) {
    var k, key, len3, results1;
    results1 = [];
    for (k = 0, len3 = keys_list.length; k < len3; k++) {
      key = keys_list[k];
      results1.push(hash[key]);
    }
    return results1;
  };
  o_match = function(criteria_obj, subject) {
    var key, val;
    for (key in criteria_obj) {
      val = criteria_obj[key];
      if (subject[key] !== val) {
        return false;
      }
    }
    return true;
  };
  o_set = function(obj, key, val) {
    return obj[key] = val;
  };
  pull = function(key, hash) {
    var val;
    val = hash[key];
    delete hash[key];
    return val;
  };
  pick = function(obj, props) {
    return pick_all(obj, rest(arguments));
  };
  pick_all = function(obj, props) {
    var k, len3, prop, res;
    res = {};
    for (k = 0, len3 = props.length; k < len3; k++) {
      prop = props[k];
      if (obj[prop] !== void 0) {
        res[prop] = obj[prop];
      }
    }
    return res;
  };
  transform = function(fn, obj, keys) {
    return keys && (transform3(fn, obj, keys)) || (transform2(fn, obj));
  };
  transform2 = function(fn, obj) {
    var key, val;
    for (key in obj) {
      val = obj[key];
      obj[key] = fn(val);
    }
    return obj;
  };
  transform3 = function(fn, obj, keys) {
    var k, key, len3;
    for (k = 0, len3 = keys.length; k < len3; k++) {
      key = keys[k];
      obj[key] = fn(obj[key]);
    }
    return obj;
  };
  update_in = function(obj, key, update_fn) {
    var val;
    if (is_defined((val = obj[key]))) {
      obj[key] = update_fn(val);
    }
    return obj;
  };
  vals = function(hash) {
    return o_map(hash, keys(hash));
  };
  zip_obj = function(keys, vals) {
    var obj;
    obj = {};
    each(partial(o_set, obj), keys, vals);
    return obj;
  };
  format = function(template_str) {
    var args;
    args = rest(arguments);
    return template_str.replace(/{(\d+)}/g, function(match, number) {
      return (typeof args[number] !== 'undefined') && args[number] || match;
    });
  };
  head = function(chars_to_take, str) {
    return str.substr(0, chars_to_take);
  };
  match = function(regexp, source_str) {
    return source_str.match(regexp);
  };
  matches = function(regexp, str) {
    if ('string' === (type_of(regexp))) {
      return (mk_regexp(regexp)).test(str);
    } else {
      return regexp.test(str);
    }
  };
  comma = function() {
    return str_join(',', slice(arguments));
  };
  space = function() {
    return str_join(' ', slice(arguments));
  };
  str = function() {
    return str_join('', slice(arguments));
  };
  str_breplace = function(map, str) {
    var regex;
    regex = mk_regexp(str_join('|', keys(map)), 'ig');
    return str.replace(regex, function(seq) {
      return map[seq] || seq;
    });
  };
  str_join = function(join_string, array_to_join) {
    return array_to_join.join(join_string);
  };
  str_split = function(split_str, string_to_split) {
    return string_to_split.split(split_str);
  };
  tail = function(chars_to_drop, str) {
    return str.substr(chars_to_drop);
  };
  trim = function(str) {
    return str.trim();
  };
  dec = function(num) {
    return num - 1;
  };
  inc = function(num) {
    return num + 1;
  };
  jquery_wrap_to_array = function(jquery_wrap) {
    var i, results1, wrap_len;
    wrap_len = jquery_wrap.length;
    i = -1;
    results1 = [];
    while (++i < wrap_len) {
      results1.push(jquery_wrap.eq(i));
    }
    return results1;
  };
  mk_regexp = function(rx_str, rx_settings) {
    rx_settings = rx_settings || "";
    return new RegExp(rx_str, rx_settings);
  };
  range = function(start_idx, end_idx, step) {
    var array, i, length;
    switch (arguments.length) {
      case 1:
        end_idx = start_idx;
        start_idx = 0;
        step = 1;
        break;
      case 2:
        step = 1;
        break;
      case 3:
        break;
      default:
        throw new Error('Bad arguments length, available signatures are for arguments length 1, 2 and 3');
    }
    length = Math.ceil((Math.abs(end_idx - start_idx)) / step);
    array = new Array(length);
    start_idx -= step;
    i = -1;
    while (++i < length) {
      array[i] = (start_idx += step);
    }
    return array;
  };
  read = function(prop_name, hash) {
    return hash[prop_name];
  };
  read_1kv = function(obj_with_1kv_pair) {
    var key;
    key = first(keys(obj_with_1kv_pair));
    return [key, read(key, obj_with_1kv_pair)];
  };

  /*
  This is a function that iterates with another function 
  over the nodes of a tree structure.
  @param fn {function} function that operates on the node.
    signature: son, parent, son_idx, depth
  @param root {hash} a tree whose children lie in the children
    list (i.e. ordered collection).
  @param depth: indicates depth of recursion
   */
  recurse = function(fn, root, depth) {
    var children, idx, k, len3, len4, m, son;
    if (depth == null) {
      depth = 0;
    }
    children = root.children;
    depth++;
    for (idx = k = 0, len3 = children.length; k < len3; idx = ++k) {
      son = children[idx];
      fn(son, root, idx, depth);
    }
    for (m = 0, len4 = children.length; m < len4; m++) {
      son = children[m];
      recurse(fn, son, depth);
    }
    return root;
  };
  sum2 = function(a, b) {
    return a + b;
  };
  a_sum = partial(reduce, sum2, 0);
  set = function(prop_name, val, hash) {
    return hash[prop_name] = val;
  };
  time = function(fn) {
    var time_end, time_start;
    time_start = Date.now();
    fn();
    time_end = Date.now();
    return time_end - time_start;
  };
  exports = ("undefined" !== typeof module) && module.exports || {};
  exports.Reduced = Reduced;
  exports.a_contains = a_contains;
  exports.a_each = a_each;
  exports.a_filter = a_filter;
  exports.a_find_index = a_find_index;
  exports.a_index_of = a_index_of;
  exports.a_map = a_map;
  exports.a_reduce = a_reduce;
  exports.a_reject = a_reject;
  exports.a_sum = a_sum;
  exports.and2 = and2;
  exports.add2 = add2;
  exports.any = any;
  exports.assign = assign;
  exports.assign_keys = assign_keys;
  exports.apply = apply;
  exports.bind = bind;
  exports.bind_all = bind_all;
  exports.butlast = butlast;
  exports.cat = cat;
  exports.clone = clone;
  exports.cloneassign = cloneassign;
  exports.clonedeep = clonedeep;
  exports.clonedeep2 = _clonedeep2;
  exports.comma = comma;
  exports.compact = compact;
  exports.compose = compose;
  exports.complement = complement;
  exports.concat = cat;
  exports.contains = contains;
  exports.count = count;
  exports.create = create;
  exports.debug_wrap = debug_wrap;
  exports.debounce = debounce;
  exports.dec = dec;
  exports.defaults = defaults;
  exports.delay = delay;
  exports.detect = find;
  exports.diff = difference;
  exports.difference = difference;
  exports.difference_sets = difference_sets;
  exports.drop = drop;
  exports.drop_last = drop_last;
  exports.each = each;
  exports.each_idx = each_idx;
  exports.equal = equal;
  exports.equal_array_start = equal_array_start;
  exports.equal_val = equal_val;
  exports.equal_set = equal_set;
  exports.every = every;
  exports.extend = extend;
  exports.fastbind = bind;
  exports.first = first;
  exports.filter = filter;
  exports.filter_fn = filter_fn;
  exports.filter_obj = filter_obj;
  exports.filter_obj_1kv = filter_obj_1kv;
  exports.filter_obj_2kv = filter_obj_2kv;
  exports.filter_prop = filter_prop;
  exports.filter_re = filter_re;
  exports.find = find;
  exports.find_index = find_index;
  exports.find_index_fn = find_index_fn;
  exports.find_index_prop = find_index_prop;
  exports.find_index_obj_1kv = find_index_obj_1kv;
  exports.find_index_obj_2kv = find_index_obj_2kv;
  exports.find_index_obj = find_index_obj;
  exports.find_index_last = find_index_last;
  exports.flatten = flatten;
  exports.flattenp = flattenp;
  exports.flatten_path = flatten_path;
  exports.flow = flow;
  exports.for_own = for_own;
  exports.format = format;
  exports.get = read;
  exports.check_keys = check_keys;
  exports.head = head;
  exports.inc = inc;
  exports.index_by = index_by;
  exports.index_by_id = partial(index_by, 'id');
  exports.index_of = index_of;
  exports.insert_at = insert_at;
  exports.intersection = intersection;
  exports.interpose = interpose;
  exports.interval = set_interval;
  exports.invoke = invoke;
  exports.invokem = invokem;
  exports.is_array = is_array;
  exports.is_boolean = is_boolean;
  exports.is_date = is_date;
  exports.is_defined = is_defined;
  exports.is_empty = is_empty;
  exports.is_empty$ = is_empty$;
  exports.is_even = is_even;
  exports.is_function = is_function;
  exports.is_mergeable = is_mergeable;
  exports.is_number = is_number;
  exports.is_object = is_object;
  exports.is_plain_object = is_plain_object;
  exports.is_string = is_string;
  exports.is_subset = is_subset;
  exports.is_zero = is_zero;
  exports.jquery_wrap_to_array = jquery_wrap_to_array;
  exports.j2a = jquery_wrap_to_array;
  exports.keys = keys;
  exports.last = last;
  exports.list = list;
  exports.list_compact = list_compact;
  exports.log_pipe = log_pipe;
  exports.map = map;
  exports.map_async = map_async;
  exports.magic = no_operation;
  exports.match = match;
  exports.matches = matches;
  exports.merge = merge;
  exports.merge_with = merge_with;
  exports.mk_regexp = mk_regexp;
  exports.multicall = multicall;
  exports.next = next;
  exports.no_operation = no_operation;
  exports.noop = no_operation;
  exports.not_array = not_array;
  exports.not_boolean = not_boolean;
  exports.not_contains = not_contains;
  exports.not_date = not_date;
  exports.not_defined = not_defined;
  exports.not_empty = not_empty;
  exports.not_empty$ = not_empty$;
  exports.not_function = not_function;
  exports.not_number = not_number;
  exports.not_object = not_object;
  exports.not_string = not_string;
  exports.not_subset = not_subset;
  exports.not_zero = not_zero;
  exports.omit = omit;
  exports.omit_all = omit_all;
  exports.o_for_own = o_for_own;
  exports.o_map = o_map;
  exports.o_match = o_match;
  exports.partial = partial;
  exports.pbind = pbind;
  exports.periodically = periodically;
  exports.pt = partial;
  exports.ptr = partialr;
  exports.partialr = partialr;
  exports.pick = pick;
  exports.pick_all = pick_all;
  exports.pipeline = flow;
  exports.pluck = pluck;
  exports.pluck_id = partial(pluck, 'id');
  exports.prev = prev;
  exports.pull = pull;
  exports.push = push;
  exports.push_all = push_all;
  exports.range = range;
  exports.read = read;
  exports.recurse = recurse;
  exports.reduce = reduce;
  exports.reducer = reducer;
  exports.reject = reject;
  exports.reject_fn = reject_fn;
  exports.reject_obj = reject_obj;
  exports.reject_obj_1kv = reject_obj_1kv;
  exports.reject_obj_2kv = reject_obj_2kv;
  exports.reject_prop = reject_prop;
  exports.remap = remap;
  exports.remove = remove;
  exports.remove_at = remove_at;
  exports.repeat = repeat;
  exports.repeatf = repeatf;
  exports.rest = rest;
  exports.reverse = reverse;
  exports.second = second;
  exports.set = set;
  exports.set_difference = difference_sets;
  exports.set_symmetric_difference = set_symmetric_difference;
  exports.slice = slice;
  exports.sort = sort;
  exports.space = space;
  exports.splice = splice;
  exports.str = str;
  exports.str_breplace = str_breplace;
  exports.str_drop = tail;
  exports.str_join = str_join;
  exports.str_split = str_split;
  exports.str_take = head;
  exports.sum2 = sum2;
  exports.sum = a_sum;
  exports.take = take;
  exports.tail = tail;
  exports.third = third;
  exports.throttle = throttle;
  exports.time = time;
  exports.transform = transform;
  exports.trim = trim;
  exports.update_in = update_in;
  exports.union = union;
  exports.unique = unique;
  exports.unshift = unshift;
  exports.vals = vals;
  exports.varynum = varynum;
  exports.without = without;
  exports.write = write;
  exports.zip_obj = zip_obj;
  return exports;
});
