// Generated by CoffeeScript 1.8.0
var __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

define(['./Emitter', 'vendor/f-empower'], function(Emitter, fn) {
  var SuperEmitter, a_contains, a_get, bind, is_array, is_function, listen, make_action_undefined_exception, map, mutate_list, partial, remove_at, to_emitter_row, vals;
  a_get = function(hash_array, row_name) {
    var row, _i, _len;
    for (_i = 0, _len = hash_array.length; _i < _len; _i++) {
      row = hash_array[_i];
      if (row[0] === row_name) {
        return row[1];
      }
    }
  };
  a_contains = fn.a_contains, bind = fn.bind, is_array = fn.is_array, is_function = fn.is_function, map = fn.map, partial = fn.partial, remove_at = fn.remove_at, vals = fn.vals;
  make_action_undefined_exception = function(action, emitter_name) {
    return new Error("ListeningError: action " + action + " is undefined for " + emitter_name);
  };
  listen = function(emitter, event_table, this_arg) {
    var action, actions, bound, bounds, event, _i, _j, _len, _len1, _ref;
    if (!emitter) {
      return;
    }
    bounds = this_arg.__bounds__;
    for (_i = 0, _len = event_table.length; _i < _len; _i++) {
      _ref = event_table[_i], event = _ref[0], actions = _ref[1];
      for (_j = 0, _len1 = actions.length; _j < _len1; _j++) {
        action = actions[_j];
        bound = ((typeof action === 'function') && action) || bounds[action] || (bounds[action] = bind(this_arg[action], this_arg));
        if ((typeof action === 'string') && !this_arg[action]) {
          throw make_action_undefined_exception(action, emitter);
        } else {
          emitter.on(event, bound);
        }
      }
    }
  };
  mutate_list = function(list, events, this_arg) {
    var old_push, old_splice, old_unshift;
    old_push = list.push;
    old_splice = list.splice;
    old_unshift = list.unshift;
    list.splice = function() {
      var i;
      i = arguments.length;
      while (--i > 1) {
        listen(arguments[i], events, this_arg);
      }
      return old_splice.apply(list, arguments);
    };
    list.push = function() {
      var emitter, _i, _len;
      for (_i = 0, _len = arguments.length; _i < _len; _i++) {
        emitter = arguments[_i];
        listen(emitter, events, this_arg);
      }
      return old_push.apply(list, arguments);
    };
    list.unshift = function() {
      var emitter, _i, _len;
      for (_i = 0, _len = arguments.length; _i < _len; _i++) {
        emitter = arguments[_i];
        listen(emitter, events, this_arg);
      }
      return old_unshift.apply(list, arguments);
    };
    return 0;
  };
  to_emitter_row = function(this_arg, _arg) {
    var emitter_name, events;
    emitter_name = _arg[0], events = _arg[1];
    if ('string' !== typeof emitter_name) {
      return [emitter_name, events];
    } else {
      return [this_arg[emitter_name], events];
    }
  };
  SuperEmitter = (function(_super) {
    __extends(SuperEmitter, _super);

    function SuperEmitter() {
      SuperEmitter.__super__.constructor.call(this);
      this.__bounds__ = {};
      this.self = this;
    }

    SuperEmitter.prototype.bind_events = function() {
      var emitter, events, item, _i, _j, _len, _len1, _ref, _ref1;
      if (!this.event_table) {
        throw new Error('SuperEmitter/bind_events: `event_table` not found');
      }
      _ref = map(partial(to_emitter_row, this), this.event_table);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        _ref1 = _ref[_i], emitter = _ref1[0], events = _ref1[1];
        if (is_array(emitter)) {
          mutate_list(emitter, events, this);
          if (emitter.length) {
            for (_j = 0, _len1 = emitter.length; _j < _len1; _j++) {
              item = emitter[_j];
              listen(item, events, this);
            }
          }
        } else {
          listen(emitter, events, this);
        }
      }
      return 0;
    };

    SuperEmitter.prototype.listen = function(emitter_name, emitter) {
      listen(emitter, a_get(this.event_table, emitter_name), this);
      return emitter;
    };

    SuperEmitter.prototype.remove_listener = function(listener) {
      var event_name, handler, handler_bundle, handler_idx, listener_bounds, _i, _ref;
      listener_bounds = vals(listener.__bounds__);
      _ref = this.handlers;
      for (event_name in _ref) {
        handler_bundle = _ref[event_name];
        for (handler_idx = _i = handler_bundle.length - 1; _i >= 0; handler_idx = _i += -1) {
          handler = handler_bundle[handler_idx];
          if (a_contains(listener_bounds, handler)) {
            remove_at(handler_idx, handler_bundle);
          }
        }
      }
    };

    SuperEmitter.prototype.unlisten = function(emitter_name, emitter) {
      var bounds, event_name, event_table, events, reaction, _i, _j, _len, _len1, _ref;
      event_table = a_get(this.event_table, emitter_name);
      bounds = this.__bounds__;
      for (_i = 0, _len = event_table.length; _i < _len; _i++) {
        _ref = event_table[_i], event_name = _ref[0], events = _ref[1];
        for (_j = 0, _len1 = events.length; _j < _len1; _j++) {
          reaction = events[_j];
          reaction = (is_function(reaction)) && reaction || bounds[reaction];
          emitter.off(event_name, reaction);
        }
      }
    };

    return SuperEmitter;

  })(Emitter);

  /*
  Performs bindings of event handlers without instance binding.
  All emitters should be objects not strings, and all actions must functions,
  not the method names.
   */
  SuperEmitter.activate_event_table = function(table) {};
  return SuperEmitter;
});
