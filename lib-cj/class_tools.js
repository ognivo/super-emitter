// Generated by CoffeeScript 1.10.0
var clonedeep, delete_key_from_collection, fn, get_from_table, index_of_key_in_collection, map, merge_blueprints, merge_event_tables, merge_mixin, merge_mixin_one, merge_partial_initializers, mix_of, multicall, name_isnt_reserved, to_objects_array, transform_events, union,
  slice = [].slice,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

fn = require("vendor/f-empower");

clonedeep = fn.clonedeep, map = fn.map, multicall = fn.multicall, union = fn.union;

delete_key_from_collection = function(key, collection) {
  var idx_of_key;
  idx_of_key = index_of_key_in_collection(key, collection);
  if (idx_of_key !== -1) {
    return collection.splice(idx_of_key, 1);
  }
};

index_of_key_in_collection = function(key, collection) {
  return fn.index_of(key, map('0', collection));
};

get_from_table = function(key, table) {
  var idx;
  idx = index_of_key_in_collection(key, table);
  if (idx < 0) {
    return null;
  } else {
    return table[idx][1];
  }
};

name_isnt_reserved = function(member_name) {
  return !(member_name === 'blueprint' || member_name === 'event_table');
};

to_objects_array = function(mixins) {
  var i, len, mixin_entry, results;
  results = [];
  for (i = 0, len = mixins.length; i < len; i++) {
    mixin_entry = mixins[i];
    results.push((('function' === typeof mixin_entry) && mixin_entry.prototype) || mixin_entry);
  }
  return results;
};

merge_blueprints = function() {
  var blueprints, i, j, len, len1, part_conf, part_name, resulting_blueprint, row, source_blueprint;
  blueprints = 1 <= arguments.length ? slice.call(arguments, 0) : [];
  blueprints = clonedeep(blueprints);
  resulting_blueprint = blueprints.shift();
  for (i = 0, len = blueprints.length; i < len; i++) {
    source_blueprint = blueprints[i];
    for (j = 0, len1 = source_blueprint.length; j < len1; j++) {
      row = source_blueprint[j];
      part_name = row[0], part_conf = row[1];
      delete_key_from_collection(part_name, resulting_blueprint);
      resulting_blueprint.push(row);
    }
  }
  return resulting_blueprint;
};

merge_partial_initializers = function(mixins) {
  return multicall(map('partial_init', mixins));
};

merge_event_tables = function() {
  var i, index_of, j, k, len, len1, len2, ref, ref1, ref2, remitter, remitter_idx, remitter_row, resulting_table, revent_idx, revent_row, revents, semitter, sevent, sevents, source_table, sreactions, tables;
  tables = 1 <= arguments.length ? slice.call(arguments, 0) : [];
  resulting_table = [];
  index_of = index_of_key_in_collection;
  for (i = 0, len = tables.length; i < len; i++) {
    source_table = tables[i];
    for (j = 0, len1 = source_table.length; j < len1; j++) {
      ref = source_table[j], semitter = ref[0], sevents = ref[1];
      remitter_idx = index_of(semitter, resulting_table);
      remitter_row = null;
      revents = null;
      if (remitter_idx === -1) {
        revents = [];
        remitter_row = [semitter, revents];
        resulting_table.push(remitter_row);
      } else {
        ref1 = resulting_table[remitter_idx], remitter = ref1[0], revents = ref1[1];
      }
      for (k = 0, len2 = sevents.length; k < len2; k++) {
        ref2 = sevents[k], sevent = ref2[0], sreactions = ref2[1];
        revent_idx = index_of(sevent, revents);
        if (revent_idx === -1) {
          revent_row = [sevent, sreactions];
          revents.push(revent_row);
        } else {
          revent_row = revents[revent_idx];
          revent_row[1] = union(revent_row[1], sreactions);
        }
      }
    }
  }
  return resulting_table;
};

mix_of = function() {
  var Base, Mixed, i, len, member, member_name, mix_proto, mixin, mixins;
  Base = arguments[0], mixins = 2 <= arguments.length ? slice.call(arguments, 1) : [];
  mixins = to_objects_array(mixins);
  Mixed = (function(superClass) {
    extend(Mixed, superClass);

    function Mixed() {
      return Mixed.__super__.constructor.apply(this, arguments);
    }

    return Mixed;

  })(Base);
  mix_proto = Mixed.prototype;
  for (i = 0, len = mixins.length; i < len; i++) {
    mixin = mixins[i];
    for (member_name in mixin) {
      member = mixin[member_name];
      if (name_isnt_reserved(member_name)) {
        mix_proto[member_name] = member;
      }
    }
  }
  mixins.unshift(Base.prototype);
  Mixed.prototype.partial_init = merge_partial_initializers(mixins);
  return Mixed;
};

merge_mixin_one = function(base_proto, mixin) {
  var base_et, member, member_name, mixin_et;
  mixin_et = mixin[ET];
  base_et = base_proto[ET];
  for (member_name in mixin) {
    member = mixin[member_name];
    if (mixin_et !== member) {
      base_proto[member_name] = member;
    }
  }
  if (mixin_et) {
    if (base_et) {
      base_proto[ET] = merge_event_tables(base_et, mixin_et);
    } else {
      base_proto[ET] = mixin_et;
    }
  }
  return base_proto;
};

merge_mixin = function(base_class_fn) {
  var base_proto, mixins;
  base_proto = base_class_fn.prototype;
  mixins = fn.rest(arguments);
  fn.reduce(merge_mixin_one, base_proto, mixins);
  return base_class_fn;
};

transform_events = function(event_table) {
  var emitter_name, emitter_row, events_pack, i, len, referenced_emitter_name;
  for (i = 0, len = event_table.length; i < len; i++) {
    emitter_row = event_table[i];
    emitter_name = emitter_row[0], events_pack = emitter_row[1];
    if (fn.is_string(events_pack)) {
      referenced_emitter_name = events_pack;
      emitter_row[1] = get_from_table(referenced_emitter_name, event_table);
      if (null === emitter_row[1]) {
        throw new Error("No emitter#" + emitter_name + " in the event_table");
      }
    }
  }
  return event_table;
};

({
  merge_blueprints: merge_blueprints,
  merge_events: merge_event_tables,
  merge_event_tables: merge_event_tables,
  merge_mixin: merge_mixin,
  merge_partial_initializers: merge_partial_initializers,
  mix_of: mix_of,
  transform_events: transform_events
});
