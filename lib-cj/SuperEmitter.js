// Generated by CoffeeScript 1.8.0
var SuperEmitter, a_contains, a_each, a_get, bind, each, first, fn, is_array, is_function, listen, make_action_undefined_exception, map, mutate_list, partial, remove_at, second, to_emitter_row, unlisten_components, vals, _unlisten_component;

fn = require("vendor/f-empower");

a_get = function(hash_array, row_name) {
  var row, _i, _len;
  for (_i = 0, _len = hash_array.length; _i < _len; _i++) {
    row = hash_array[_i];
    if (row[0] === row_name) {
      return row[1];
    }
  }
};

a_contains = fn.a_contains, a_each = fn.a_each, bind = fn.bind, each = fn.each, is_array = fn.is_array, is_function = fn.is_function, first = fn.first, map = fn.map, partial = fn.partial, remove_at = fn.remove_at, second = fn.second, vals = fn.vals;

make_action_undefined_exception = function(action, emitter_name) {
  return new Error("ListeningError: action " + action + " is undefined for " + emitter_name);
};

listen = function(emitter, event_table, this_arg) {
  var action, actions, bound, bounds, event, _i, _j, _len, _len1, _ref;
  if (!emitter) {
    return;
  }
  bounds = this_arg.__bounds__;
  for (_i = 0, _len = event_table.length; _i < _len; _i++) {
    _ref = event_table[_i], event = _ref[0], actions = _ref[1];
    for (_j = 0, _len1 = actions.length; _j < _len1; _j++) {
      action = actions[_j];
      bound = ((typeof action === 'function') && action) || bounds[action] || (bounds[action] = bind(this_arg[action], this_arg));
      if ((typeof action === 'string') && !this_arg[action]) {
        throw make_action_undefined_exception(action, emitter);
      } else {
        if (emitter.on) {
          emitter.on(event, bound);
        } else {
          emitter.addEventListener(event, bound);
        }
      }
    }
  }
};

mutate_list = function(list, events, this_arg) {
  var old_push, old_splice, old_unshift;
  old_push = list.push;
  old_splice = list.splice;
  old_unshift = list.unshift;
  list.splice = function() {
    var i;
    i = arguments.length;
    while (--i > 1) {
      listen(arguments[i], events, this_arg);
    }
    return old_splice.apply(list, arguments);
  };
  list.push = function() {
    var emitter, _i, _len;
    for (_i = 0, _len = arguments.length; _i < _len; _i++) {
      emitter = arguments[_i];
      listen(emitter, events, this_arg);
    }
    return old_push.apply(list, arguments);
  };
  list.unshift = function() {
    var emitter, _i, _len;
    for (_i = 0, _len = arguments.length; _i < _len; _i++) {
      emitter = arguments[_i];
      listen(emitter, events, this_arg);
    }
    return old_unshift.apply(list, arguments);
  };
};

to_emitter_row = function(this_arg, _arg) {
  var emitter_name, events;
  emitter_name = _arg[0], events = _arg[1];
  if ('string' !== typeof emitter_name) {
    return [emitter_name, events];
  } else {
    return [this_arg[emitter_name], events];
  }
};

_unlisten_component = function(listener, component, events) {
  var bounds;
  bounds = listener.__bounds__;
  return a_each(events, function(_arg) {
    var event_handlers_names, event_name;
    event_name = _arg[0], event_handlers_names = _arg[1];
    return a_each(event_handlers_names, function(handler_name) {
      var bounded_handler;
      bounded_handler = bounds[handler_name];
      return component.off(event_name, bounded_handler);
    });
  });
};

unlisten_components = function(listener, components_with_events) {
  return a_each(components_with_events, function(_arg) {
    var component, components_array, events;
    component = _arg[0], events = _arg[1];
    if (is_array(component)) {
      components_array = component;
      return a_each(components_array, function(component) {
        return _unlisten_component(listener, component, events);
      });
    } else {
      return _unlisten_component(listener, component, events);
    }
  });
};

SuperEmitter = (function() {
  function SuperEmitter() {
    this.handlers = {};
    this.__bounds__ = {};
    this.self = this;
  }

  SuperEmitter.prototype.bind_events = function() {
    var emitter, events, item, _i, _j, _len, _len1, _ref, _ref1;
    if (!this.event_table) {
      throw new Error('SuperEmitter/bind_events: `event_table` not found');
    }
    _ref = map(partial(to_emitter_row, this), this.event_table);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      _ref1 = _ref[_i], emitter = _ref1[0], events = _ref1[1];
      if (is_array(emitter)) {
        mutate_list(emitter, events, this);
        if (emitter.length) {
          for (_j = 0, _len1 = emitter.length; _j < _len1; _j++) {
            item = emitter[_j];
            listen(item, events, this);
          }
        }
      } else {
        listen(emitter, events, this);
      }
    }
  };

  SuperEmitter.prototype.dispose = function() {
    var components_with_events;
    components_with_events = this.get_components_listened();
    unlisten_components(this, components_with_events);
    return this.off();
  };

  SuperEmitter.prototype.get_components_listened = function() {
    var component_names, components, components_events;
    component_names = map(first, this.event_table);
    components = map(this, component_names);
    components_events = map(second, this.event_table);
    return map(Array, components, components_events);
  };


  /*
  Emits specified event with given arguments array.
  I chose the array form to visually separate event emissions
  from simple method calls.
  Beware that args array is not cloned.
  @param event_name {string}
  @param args {array}
   */

  SuperEmitter.prototype.emit = function(event_name, args) {
    var handlers, hlen, i, res;
    handlers = this.handlers[event_name];
    if (!handlers) {
      return;
    }
    i = -1;
    res = null;
    while (++i < (hlen = handlers.length)) {
      res = handlers[i].apply(this, args);
      if ((typeof res === 'boolean') && !res) {
        return;
      }
    }
  };

  SuperEmitter.prototype.listen = function(emitter_name, emitter) {
    listen(emitter, a_get(this.event_table, emitter_name), this);
    return emitter;
  };


  /*
  Unbinds events.
  By default function removes all handlers from all events.
  @param {string} event_name if specified, removes handlers of only that event.
  @param {function} handler if specified, unbinds only that one handler.
   */

  SuperEmitter.prototype.off = function(event_name, handler) {
    var event_handlers, i, _ref;
    if (event_name) {
      event_handlers = this.handlers[event_name];
      if (!event_handlers) {
        throw new Error("No handlers bound for event " + event_name);
      }
      if (!handler) {
        event_handlers.length = 0;
      } else {
        i = event_handlers.length;
        while (--i >= 0) {
          if (event_handlers[i] === handler) {
            event_handlers.splice(i, 1);
          }
        }
      }
    } else {
      _ref = this.handlers;
      for (event_name in _ref) {
        event_handlers = _ref[event_name];
        event_handlers.length = 0;
      }
    }
  };


  /*
  Binds handler to the specified event
   */

  SuperEmitter.prototype.on = function(event_name, handler) {
    var handlers;
    handlers = this.handlers;
    handlers[event_name] = handlers[event_name] || [];
    handlers[event_name].push(handler);
  };

  SuperEmitter.prototype.remove_listener = function(listener) {
    var event_name, handler, handler_bundle, handler_idx, listener_bounds, _i, _ref;
    listener_bounds = vals(listener.__bounds__);
    _ref = this.handlers;
    for (event_name in _ref) {
      handler_bundle = _ref[event_name];
      for (handler_idx = _i = handler_bundle.length - 1; _i >= 0; handler_idx = _i += -1) {
        handler = handler_bundle[handler_idx];
        if (a_contains(listener_bounds, handler)) {
          remove_at(handler_idx, handler_bundle);
        }
      }
    }
  };

  SuperEmitter.prototype.unlisten = function(emitter_name, emitter) {
    var bounds, event_name, event_table, events, reaction, _i, _j, _len, _len1, _ref;
    event_table = a_get(this.event_table, emitter_name);
    bounds = this.__bounds__;
    for (_i = 0, _len = event_table.length; _i < _len; _i++) {
      _ref = event_table[_i], event_name = _ref[0], events = _ref[1];
      for (_j = 0, _len1 = events.length; _j < _len1; _j++) {
        reaction = events[_j];
        reaction = (is_function(reaction)) && reaction || bounds[reaction];
        emitter.off(event_name, reaction);
      }
    }
  };

  SuperEmitter.prototype.___ = function() {
    return false;
  };

  return SuperEmitter;

})();


/*
Performs bindings of event handlers without instance binding.
All emitters should be objects not strings, and all actions must functions,
not the method names.
 */

SuperEmitter.activate_event_table = function(table) {};

SuperEmitter;
